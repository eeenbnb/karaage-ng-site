{"2021-05-13":"# Node.jsでHTMLを取得してparseして必要なデータを取得する\n<div class=\"info\">\n  <p class=\"info__date\">\n    2021/05/16\n  </p>\n  <div class=\"info__tags\">\n    <p class=\"info__tags__one\">Node.js</p>\n  </div>\n</div>\n\n## はじめに\nスクレイピングをする機会が多いのでメモとして残す。\n\n## htmlを取得する\n`url` を渡して取得する。コメントを外せば保存ができるようにしてある。\n~~エラー対策してないのは割愛~~\n\n```javascript\nconst get = (url) =>{\n  return new Promise((resolve, reject)=>{\n    request.get({\n      uri: url,\n      headers: {'Content-type': 'text/html;'},\n    }, function(err, req, data){\n      if(req.statusCode == 200){\n        resolve(data)\n        //fs.writeFileSync(path.resolve(__dirname,`./temp-${Date.now()}.html`), data);\n      }\n      console.log(\"complate:\",url);\n      resolve(\"\");\n    });\n  })\n}\n```\n\n## htmlをパースする\n\n`JSDOM` を使ってHTMLをパースして `window` から色々取れるようになる。  \n~~`javascript` で描画されるものは対応してないっぽいので、ちょっと処理が重くなっちゃうけど `Headless Chrome` とかの方が良いかも。~~  \n~~試してはない `document.addEventListener(\"DOMContentLoaded\",()=>{...})` みたいに取得できたら良いかなと思おうけど非同期処理を入れる必要があるかな。~~  \n`runScripts: \"dangerously\"` プロパティを設定すると `js` などが走るっぽい。  \n`resources: \"usable\"` を設定することで外部リソースの利用を許可する。\n\n\n```javascript\nconst htmlParse = (htmlText) =>{\n  try{\n    const dom = new JSDOM(htmlText,{\n      runScripts: \"dangerously\",\n      resources: \"usable\"\n    });\n    // get element\n    const text = dom.window.document.title;\n    console.log(`text:`,text);\n  }catch (e){\n    console.error(e)\n  }\n}\n```\n\n## 全体\n`url.txt` からUrl群を取得してUrlからHTMLを取得する。\n\n```javascript\nconst fs = require('fs');\nconst glob = require('glob');\nconst request = require('request');\nconst path = require('path');\nconst { JSDOM } = require('jsdom')\n\nconst urls = fs\n  .readFileSync(\n    path.resolve(__dirname,\"url.txt\"),'utf8'\n  )\n  .split('\\n')\n  .filter(t=>t.length > 0);\n\nconst get = (url) =>{\n  return new Promise((resolve, reject)=>{\n    request.get({\n      uri: url,\n      headers: {'Content-type': 'text/html;'},\n    }, function(err, req, data){\n      if(req.statusCode == 200){\n        resolve(data)\n        //fs.writeFileSync(path.resolve(__dirname,`./temp-${Date.now()}.html`), data);\n      }\n      console.log(\"complate:\",url);\n      resolve(\"\");\n    });\n  })\n}\n\nconst htmlParse = (htmlText) =>{\n  try{\n    const dom = new JSDOM(htmlText,{\n      runScripts: \"dangerously\",\n      resources: \"usable\"\n    });\n    // get element\n    setTimeout(()=>{\n      const text = dom.window.document.title;\n      console.log(`text:`,text);\n    },1000);\n  }catch (e){\n    console.error(e)\n  }\n}\n\nPromise.all(urls.map(url=>get(url))).then((htmls)=>{\n  htmls.forEach((html) => {\n    htmlParse(html)\n  });\n});\n\n// glob.sync(path.resolve(__dirname,`./temp-*.html`)).forEach((p)=>{\n//   fs.unlinkSync(p);\n// });\n```\n\n## 終わりに\n\n- `JSDOM` に `fromURL()` というメソッドがあるのでHTMLファイルとして保存しない場合  `request` が必要ないかも。\n  - `fromFile()` メソッドもあるので保存したHTMLファイルから再開も `fs` を使わないでできそう。\n\n```javascript\nJSDOM.fromURL(\"https://example.com/\", options).then(dom => {\n  console.log(dom.serialize());\n});\n```\n\n- `window.matchMedia` がない。\n  - `Headless Chrome` でいいかな…。\n"}